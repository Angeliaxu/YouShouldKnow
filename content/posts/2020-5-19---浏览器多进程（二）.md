---
title: 浏览器多进程（二）
date: "2020-05-19"
template: "post"
draft: false
slug: "/post/browserMutiProcess/"
category: "JavaScript"
tags: 
    - "js"
description: "之前有写过文章介绍浏览器多进程，这篇文章在此基础上又深入的了解了浏览器多进程，从为什么浏览器是多进程到输入url到页面显示，诠释浏览器多进程是怎么样协作。"
socialImage: "/media/42-line-bible.jpg"
---
之前有写过文章介绍浏览器多进程，[点击查看](https://angeliablock.cn/post/browserStructure/)，这篇文章在此基础上又深入的了解了浏览器多进程，从为什么浏览器是多进程到输入url到页面显示，诠释浏览器多进程是怎么样协作。
  

### Part1  
  
要了解浏览器多进程，需要了解并行处理：同一时刻处理多个任务，提升性能，在计算中具体的表现是多线程，线程在计算中是不能单独存在的，是由进程来启动和管理，一个进程就是一个程序的运行是咧，启动一个程序的时候，操作系统会为该程勋创建一块内存，用来存放代码，运行数据和一个执行任务的主线程，把这样的一个环境叫做进程。   

线程依附于进程，而进程使用线程并行处理提升运算效率，进程和线程之间的关系特点：
1. 某个线程崩溃，将引起某一进程整体崩溃
2. 线程之间共享进程的公共数据，可以进行读写操作
3. 当一个进程关之后，操作系统会回收进程所占用的空间，即使线程操作不当导致内存泄露，当进程退出时，这些内存也会得到很好的回收
4. 进程之间的内容相互隔离（进程隔离是为了保护操作系统中互不干扰的技术）。如果进程之间需要通信，就需要使用进程通信机制（IPC机制）

在2007年之前，市面上的浏览器都是单进程浏览器，大致结构如下

早期浏览器，主要某一个页面崩溃，会导致其他页面也跟着崩溃，因为所有页面使用的是同一套进程，没有区分，这也是为什么要采取多进程浏览器的原因。采用多进程浏览器的好处就是：使用安全沙箱把浏览器进程锁在里面（操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在硬盘上写入任何数据，不能在敏感位置读取任何进程）。

chrome把插件进程和渲染进程锁在沙箱里面，即使插件进程或者渲染进程里面执行了恶意代码，恶意程序也没办法跨过沙箱去获取系统权限。目前浏览器多进程架构如下：

1. 浏览器进程：主要负责界面显示，用户交互，子进程管理，同时提供存储能力
2. 渲染进程：html，js，css转为网页排版引擎Blink和JS引擎v8运行在此进程当中，默认情况下chrome会为每个tab标签创建一个渲染进程
3. GPU进程：初衷是为了实现3D CSS效果，之后的chrome ui界面都选择采用GPU来绘制，使得GPU成为浏览器的普遍需求，之后，chrome在多进程架构上引入了GPU进程
4. 网络进程：负责页面的网络资源加载，之前是作为一个单独的模块运行在浏览器进程里面，直至最近才独立出来成为浏览器的的一个单独进程
5. 插件进程： 插件易崩溃，所以需要进程来隔离来保证不会对浏览器产生页面影响

上面2中提到了渲染进程默认情况下会为每一个tab页面开启一个进程，其实还有其他情况，比如来自同一站点的页面，根域名与协议一样，如果从一个页面当中打开另外一个页面，新页面和当前页面属于同一站点，新页面会复用父亲的渲染进程，共享JS欢姐，A页面可以在B页面当中运行脚本。接下来就看看怎么具体计算chrome中的渲染进程个数
###### 标签页之间的连接
1. 通过`<a></a>`标签来新建标签
2. 通过window.open方式新建标签页

无论使用哪一种方式打开新标签页，他们之间都可以通过window.opener来建立连接，在WhatWG规范当中，把这一类具有相互连接关系的标签页称为浏览上下文组，还需要了解一下浏览上下文，通常情况下，把一个标签页所包含的内容，比如什么window，历史记录，滚动条位置等一系列信息称为浏览上下文，这些通过脚本连接起来的浏览上下文就是浏览上下文组。chrome浏览器会将浏览上下文组中属于同一站点的标签分配到同一渲染进程当中，因为一组标签页即在同一个浏览器上下文组中，又属于同一站点，那么他们可能需要在对方的标签页当中执行脚本，所以就把它们分配到同一浏览器当中了。凡是有列外，悄悄埋个伏笔。
下图中是我打开的一个站点，在chrome的任务管理器可以看到，为当前这个页面分配了一个进程ID为79835的浏览器进程，网址为http://www.mokahr.com/solution/retail ，与上一个页面顶级域名相同，协议相同，所以复用的是同一个渲染进程，进程ID为79835

![http3](/media/WechatIMG732.png)
当我点击免费试用按钮之后，去到了B页面，网址为http://www.mokahr.com/trial

![http3](/media/WechatIMG735.png)

我在B页面点击登录按钮后，去到了C页面，网址为https://app.mokahr.com/login?redirectUrl=%2F ，可以看到顶级域名一样，协议不一样，同时重新为这个页面分配了渲染进程，ID为79852。有兴趣可以去实操一下，同时在B页面中使用window.openner属性做些操作，去到A页面，你是可以看到操作结果的。

![http3](/media/WechatIMG737.png)

小结：上面说清楚了怎么计算浏览器进程
但是，当我给a标签加上rel = noopener noreferrer属性之后，上面的B页面不再复用A页面的进程了

![http3](/media/WechatIMG738.png)

此时的B页面被重新分配了新的渲染进程，进程ID为79835，A页面的ID为79875

![http3](/media/WechatIMG739.png)

所以，在开发过程中遇到B页面足够大的时候，我们需要把B页面从A页面中分离出去，当页面B崩溃，不会影响A页面，这也算是页面性能优化的一个点，提升用户体验。


### Part2
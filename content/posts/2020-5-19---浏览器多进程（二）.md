---
title: 浏览器多进程（二）
date: "2020-05-19"
template: "post"
draft: false
slug: "/post/browserMutiProcess/"
category: "JavaScript"
tags:
  - "js"
description: "之前有写过文章介绍浏览器多进程，这篇文章在此基础上又深入的了解了浏览器多进程，从为什么浏览器是多进程到输入url到页面显示，诠释浏览器多进程是怎么样协作。"
socialImage: "/media/42-line-bible.jpg"
---

之前有写过文章介绍浏览器多进程，[点击查看](https://angeliablock.cn/post/browserStructure/)，这篇文章在此基础上又深入的了解了浏览器多进程，从为什么浏览器是多进程到输入 url 到页面显示，诠释浏览器多进程是怎么样协作。

### Part1

要了解浏览器多进程，需要了解并行处理：同一时刻处理多个任务，提升性能，在计算中具体的表现是多线程，线程在计算中是不能单独存在的，是由进程来启动和管理，一个进程就是一个程序的运行是咧，启动一个程序的时候，操作系统会为该程勋创建一块内存，用来存放代码，运行数据和一个执行任务的主线程，把这样的一个环境叫做进程。

线程依附于进程，而进程使用线程并行处理提升运算效率，进程和线程之间的关系特点：

1. 某个线程崩溃，将引起某一进程整体崩溃
2. 线程之间共享进程的公共数据，可以进行读写操作
3. 当一个进程关之后，操作系统会回收进程所占用的空间，即使线程操作不当导致内存泄露，当进程退出时，这些内存也会得到很好的回收
4. 进程之间的内容相互隔离（进程隔离是为了保护操作系统中互不干扰的技术）。如果进程之间需要通信，就需要使用进程通信机制（IPC 机制）

在 2007 年之前，市面上的浏览器都是单进程浏览器，大致结构如下

早期浏览器，主要某一个页面崩溃，会导致其他页面也跟着崩溃，因为所有页面使用的是同一套进程，没有区分，这也是为什么要采取多进程浏览器的原因。采用多进程浏览器的好处就是：使用安全沙箱把浏览器进程锁在里面（操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在硬盘上写入任何数据，不能在敏感位置读取任何进程）。

chrome 把插件进程和渲染进程锁在沙箱里面，即使插件进程或者渲染进程里面执行了恶意代码，恶意程序也没办法跨过沙箱去获取系统权限。目前浏览器多进程架构如下：

1. 浏览器进程：主要负责界面显示，用户交互，子进程管理，同时提供存储能力
2. 渲染进程：html，js，css 转为网页排版引擎 Blink 和 JS 引擎 v8 运行在此进程当中，默认情况下 chrome 会为每个 tab 标签创建一个渲染进程
3. GPU 进程：初衷是为了实现 3D CSS 效果，之后的 chrome ui 界面都选择采用 GPU 来绘制，使得 GPU 成为浏览器的普遍需求，之后，chrome 在多进程架构上引入了 GPU 进程
4. 网络进程：负责页面的网络资源加载，之前是作为一个单独的模块运行在浏览器进程里面，直至最近才独立出来成为浏览器的的一个单独进程
5. 插件进程： 插件易崩溃，所以需要进程来隔离来保证不会对浏览器产生页面影响

上面 2 中提到了渲染进程默认情况下会为每一个 tab 页面开启一个进程，其实还有其他情况，比如来自同一站点的页面，根域名与协议一样，如果从一个页面当中打开另外一个页面，新页面和当前页面属于同一站点，新页面会复用父亲的渲染进程，共享 JS 欢姐，A 页面可以在 B 页面当中运行脚本。接下来就看看怎么具体计算 chrome 中的渲染进程个数

###### 标签页之间的连接

1. 通过`<a></a>`标签来新建标签
2. 通过 window.open 方式新建标签页

无论使用哪一种方式打开新标签页，他们之间都可以通过 window.opener 来建立连接，在 WhatWG 规范当中，把这一类具有相互连接关系的标签页称为浏览上下文组，还需要了解一下浏览上下文，通常情况下，把一个标签页所包含的内容，比如什么 window，历史记录，滚动条位置等一系列信息称为浏览上下文，这些通过脚本连接起来的浏览上下文就是浏览上下文组。chrome 浏览器会将浏览上下文组中属于同一站点的标签分配到同一渲染进程当中，因为一组标签页即在同一个浏览器上下文组中，又属于同一站点，那么他们可能需要在对方的标签页当中执行脚本，所以就把它们分配到同一浏览器当中了。凡是有列外，悄悄埋个伏笔。
下图中是我打开的一个站点，在 chrome 的任务管理器可以看到，为当前这个页面分配了一个进程 ID 为 79835 的浏览器进程，网址为http://www.mokahr.com/solution/retail ，与上一个页面顶级域名相同，协议相同，所以复用的是同一个渲染进程，进程 ID 为 79835

![http3](/media/image1.png)
当我点击免费试用按钮之后，去到了 B 页面，网址为http://www.mokahr.com/trial

![http3](/media/image2.png)

我在 B 页面点击登录按钮后，去到了 C 页面，网址为https://app.mokahr.com/login?redirectUrl=%2F ，可以看到顶级域名一样，协议不一样，同时重新为这个页面分配了渲染进程，ID 为 79852。有兴趣可以去实操一下，同时在 B 页面中使用 window.openner 属性做些操作，去到 A 页面，你是可以看到操作结果的。

![http3](/media/image3.png)

小结：上面说清楚了怎么计算浏览器进程
但是，当我给 a 标签加上 rel = noopener noreferrer 属性之后，上面的 B 页面不再复用 A 页面的进程了

![http3](/media/image4.png)

此时的 B 页面被重新分配了新的渲染进程，进程 ID 为 79835，A 页面的 ID 为 79875

![http3](/media/image5.png)

所以，在开发过程中遇到 B 页面足够大的时候，我们需要把 B 页面从 A 页面中分离出去，当页面 B 崩溃，不会影响 A 页面，这也算是页面性能优化的一个点，提升用户体验。

### Part2

衡量 web 页面性能有一个重要的指标是 FP（first paint），指页面从加载到首次开始绘制时长，影响 FP 的指标有一个重要的原因：网络加载速度。在网络中，文件会被拆分成数据包，数据包在传输过程中可能会丢失，如何保证页面文件能被完整送达浏览器，我们需要了解一下互联网的体系架构。

1. IP：把数据包送达目的主机，会在数据包上打上 B 主机的地址，A 主机地址等附加信息，附加信息会被添加进一个 IP 头的数据结构当中
2. UDP：把数据包送达到应用程序，数据包到达目的主机之后，目标主机怎么判断这个数据包交给哪个应用程序。这时候需要基于 IP 开发和能和应用程序通信的协议。最常见的是用户数据包协议（user datagram protocol）
   UDP 中有个重要信息是端口号，每个想访问网络程序都需要绑定一个端口号，通过端口号 UDP 就能把指定的数据包发送给指定的应用程序，因此，IP 找主机，UDP 找应用程序。

众所周知，UDP 的缺点是丢包，并且 UDP 不会重组数据包。为了解决这两个问题，TCP 就出现了。

TCP 是一种面向连接的，可靠的，基于字节流的传输层通信协议，相对于 UDP，TCP 有以下特点

1. 数据包丢失，提供可重传机制
2. 把数据包重组成完整的文件形式
3. TCP 头新增数据包排列的序号

一个完整的 TCP 连接包括：

1. 建立连接，三次握手阶段
2. 传输数据阶段，接收端需要对每个数据包进行确认操作，发送端发送数据，在一定时间内没有接受到接收端的反馈消息，则判断数据包丢失，触发重传机制。
3. 断开连接，四次握手

结合以上的知识点，我就来总结一下对于关于在页面输入 URL 到展示经历什么

1. 浏览器根据有无 beforeunload 时间来判断是否向网络进程提交 URL，有拦截就不做任何响应，没有就提交 URL
2. 网络进程拿到 URL 进行 DNS 查询（这一过程有缓存走缓存，没缓存就需要请求去查找），查找到 IP，判断有无本地缓存（协商缓存与强缓存），没有的话建立 TCP 连接，构建 http 请求头和请求体，然后根据返回内容判断有无重定向，有重定向就需要重走 2 操作，没有的话继续走，网络进程拿到数据之后通过 IPC 方式告诉浏览器进程，浏览器进程向渲染进程提交导航消息（从 URL 到页面开始解析这个过程叫做导航）。
3. 网络进程与渲染进程通信，渲染进程会判断响应的 URL 是否来自同一站点（但是这里是在导航栏输入 URl，所以不存在同一站点的情况），渲染进程解析 js，css，html 来构造页面，完毕之后想浏览器进程发送提供文档消息。
4. 浏览器进程收到渲染进程的提交文档消息，更显当前页面

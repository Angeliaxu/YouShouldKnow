---
title: JS执行上下文
date: "2020-6-29"
template: "post"
draft: false
slug: "/post/JSContext/"
category: "JavaScript"
tags:
  - "js"
description: "所谓变量提升，就是JS在执行过程中，JS引擎把变量的声明部分和函数的声明部分提升到代码开头的”行为“，会给变量设置默认值，这个默认值就是undefined。变量和函数声明在代码的位置是不会改变的，是在编译阶段被JS引擎放入内存中。JS的执行机制：先编译再执行"
socialImage: "/media/42-line-bible.jpg"
---

所谓变量提升，就是JS在执行过程中，JS引擎把变量的声明部分和函数的声明部分提升到代码开头的”行为“，会给变量设置默认值，这个默认值就是undefined。
变量和函数声明在代码的位置是不会改变的，**是在编译阶段被JS引擎放入内存中**。JS的执行机制：先编译再执行。代码通过编译，可以分为可执行上下文与可执行代码，例如

![537efd9e96771dc50737117e615533c](/media/QQ20200629-235736.png)

1. 如果是同名的函数，JS编译阶段会选择最后声明的那个
2. 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略

上面描述的是普遍的情况，但是现实中，还存在一些非正常性行为
```
function foo(){
    console.log(g);
    if(true){
        console.log(hello world);
        function g(){ return true; }
    }
}
```
上述代码等同于

```
function foo(){
    console.log(g);
    if(true){
        console.log(hello world);
        var g = function(){return true;}
    }
}
```

ES6规定，块级作用域（这里需要区分块级作用域与函数作用域是不同的概念）中声明函数和通过let声明变量的行为类似，所以理论上在上面代码中打印g应该是not defined，但是各大浏览器没有遵守这个规定，为了向下兼容，块级作用域中声明函数等同于函数表达式，所以在浏览器中打印g是undefined。

ES6通过引入块级作用域配合let、const来避开var的缺陷，但是JS需要保证向下兼容，1. 变量提升机制还会存在，2 **新老机制同时运行在一套系统里**。
如果一种语言支持块级作用域，那么代码块内部定义的变量外部是访问不到的，代码块执行完成之后，代码款中定义的变量将会被销毁。ES6引入let和const，使JS像其他语言一样拥有了块级作用域，在同一段代码中，JS是如何既要支持变量提升属性，又要支持块级作用域？下面通过一段代码来解析
```
function add(){
    var a = 1;
    let b = 2 ;
    { 
        let b = 3 ;
        var c = 4 ;
        let d = 5 ;
        console.log(a);
        console.log(b) ;
    } 
    console.log(b);
    console.log(c);
    console.log(d)
} 
add()
```

首先这段代码被编译，因为add是一个函数，**所以在函数执行的时候就会被编译创建上下文**，站在执行上下文角度来看
1. 第一步编译代码并创建上下文-> foo函数执行上下文
2. 通过var声明的变量，编译阶段放进变量环境里面
3. 通过let声明的变量。编译阶段放到词法环境里面
3. 块级内部变量，let声明变量不放进词法环境
![537efd9e96771dc50737117e615533c](/media/QQ20200630-003153@2x.png)
接着编译完成之后，开始执行代码
![537efd9e96771dc50737117e615533c](/media/QQ20200630-003007@2x.png)
4. 当执行到块级作用域的时候，let或者const声明的变量会在进入块级作用域的时被创建，但是在该变量没有赋值之前，引用该变量JavaScript引擎会抛出错误（暂时性死区），这时候执行上下文为，
![537efd9e96771dc50737117e615533c](/media/QQ20200630-003051@2x.png)
在词法环境内部，维护了一个小型栈结构，栈底层是最外层的变量，进入一个作用域块后，就会把该作用域块内部变量压到栈顶，当作用域块执行完成之后，该作用域信息就会从栈顶弹出，这就是词法环境的结构。
5. 代码继续往下执行，这时候的信息为

![537efd9e96771dc50737117e615533c](/media/QQ20200630-002516@2x.png)

6. 接着就是执行代码中console部分了，变量查找规则为，沿着词法环境栈顶向下查询，如果再词法环境中的某个模块找到了，就直接返回JS引擎，若无，继续在变量环境中找。所以log a的时候，词法作用域中没找到，去了环境变量中，找到a为1，b在词法作用域中栈顶找到了，b为3，接着是函数上下中的logb，在词法作用域最下层找到，为2，接着就是c和d了，d由于找不到，报错。
当作用域块执行结束后，其内部定义的变量会从词法环境中顶部弹出。
![537efd9e96771dc50737117e615533c](/media/QQ20200630-003007@2x.png)

块级作用域是通过访问词法环境栈结构实现，变量提升是通过变量坏境来实现的，两者结合，JS引擎同时支持变量提升和块级作用域。

思考：
 在编译阶段，通过let和const声明的变量和var声明的变量都被创建并且赋值为undefined，那为什么在let或者const声明之前去取声明的变量会报错，这就是let和const不同于var的另一点，虽然在编译阶段已被创建，但是在未真正赋值之前去取，就是暂时性死区，ES6的语法规定。
 函数只会在第一执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定下来，当执行到块级作用域时，其是通过let或const声明的变量会追加到词法环境中，执行完毕之后，追加到词法作用域的内容又会被销毁。

 1. var的**创建**，**初始化**会被提升，**赋值**不会被提升
 2. let或const的**创建**被提升，**初始化**和**赋值**不会被提升
 3. function的**创建**，**初始化**，**赋值**均会被提升


